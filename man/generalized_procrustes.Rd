% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_generic.R, R/genprocrustes.R
\name{generalized_procrustes}
\alias{generalized_procrustes}
\alias{generalized_procrustes.hyperdesign}
\title{Generalized Orthogonal Procrustes Alignment}
\usage{
generalized_procrustes(
  A_list,
  task_labels_list,
  L,
  max_iter = 100,
  tol = 1e-06,
  tol_type = c("relative", "absolute"),
  verbose = FALSE,
  svd_method = c("irlba", "base"),
  svd_opts = list()
)

generalized_procrustes(
  A_list,
  task_labels_list,
  L,
  max_iter = 100,
  tol = 1e-06,
  tol_type = c("relative", "absolute"),
  verbose = FALSE,
  svd_method = c("irlba", "base"),
  svd_opts = list()
)

\method{generalized_procrustes}{hyperdesign}(
  data,
  y,
  preproc = center(),
  max_iter = 100,
  tol = 1e-06,
  tol_type = c("relative", "absolute"),
  verbose = FALSE,
  svd_method = c("irlba", "base"),
  svd_opts = list(),
  ...
)
}
\arguments{
\item{A_list}{A list of length \eqn{n}, where each element \eqn{A_i} is a 
\eqn{d x li} numeric matrix representing the observed data for subject 
\eqn{i}. Each subject might have different \eqn{li < L}.}

\item{task_labels_list}{A list of length \eqn{n}, where 
\eqn{task_labels_list[[i]]} is an integer (or numeric) vector of length 
\eqn{li}, specifying which global tasks each column of \eqn{A_i} 
corresponds to (in \eqn{1..L}).}

\item{L}{Integer. The total number of distinct tasks across all subjects.}

\item{max_iter}{Maximum number of iterations (default: 100)}

\item{tol}{Convergence tolerance (default: 1e-6)}

\item{tol_type}{Type of tolerance check (default: "relative")}

\item{verbose}{Whether to print progress messages (default: FALSE)}

\item{svd_method}{SVD method to use (default: "irlba")}

\item{svd_opts}{Options for SVD method (default: empty list)}

\item{data}{A hyperdesign object containing multiple data domains}

\item{y}{Name of the task/label variable to use for alignment}

\item{preproc}{Preprocessing function to apply to the data (default: 
\code{center()})}

\item{...}{Additional arguments (currently unused)}
}
\value{
The return value depends on the specific method:
\itemize{
  \item For hyperdesign objects: A list containing orthogonal transformation 
    matrices, consensus matrix, convergence information, and domain metadata
  \item For direct matrix input: A list with transformation matrices and 
    alignment results
}

A list with:
\item{O_mats}{List of \eqn{n} orthogonal \eqn{d \times d} matrices.}
\item{A_est}{A \eqn{d \times L} consensus matrix. Columns corresponding to 
  tasks observed by no subjects will contain \code{NA}.}
\item{iterations}{Number of iterations performed.}
\item{converged}{Logical indicating whether the GPM converged.}
\item{final_diff}{The final difference value (`sqrt(diff_sq)`) used for the 
  convergence check.}
}
\description{
Performs Generalized Orthogonal Procrustes alignment to find orthogonal 
transformations. Aligns data from multiple domains by minimizing squared 
differences between corresponding task observations.

Extends Generalized Orthogonal Procrustes to handle partial task 
observations. Uses efficient sparse matrix operations and robust 
initialization.
}
\details{
This method extends classical Procrustes analysis to handle partial task 
observations, where each domain may observe only a subset of a global set of 
tasks. The algorithm uses an efficient Generalized Power Method (GPM) with 
sparse matrix operations and robust initialization to find optimal orthogonal 
transformations.


The Generalized Procrustes problem seeks to find orthogonal matrices 
\eqn{O_i} for each domain \eqn{i} that minimize:
\deqn{\sum_{i,j} \sum_{k \in T_{ij}} ||O_i^T A_i(:,k) - O_j^T A_j(:,k)||^2}

where \eqn{T_{ij}} represents the set of tasks observed by both domains 
\eqn{i} and \eqn{j}.

The algorithm handles several key challenges:
\itemize{
  \item \strong{Partial observations}: Each domain may observe different 
    subsets of tasks
  \item \strong{Sparse structure}: Uses efficient sparse matrix operations 
    for scalability
  \item \strong{Robust initialization}: SVD-based initialization with 
    fallback to random orthogonal matrices
  \item \strong{Convergence guarantees}: Monotonic improvement with 
    configurable tolerance
}

Key features:
\itemize{
  \item Vectorized operations using sparse matrix algebra
  \item Efficient projection onto the orthogonal group O(d)
  \item Optional tightness certificate for global optimality validation
  \item Flexible preprocessing and multiple input formats
}

\strong{Sparse Construction of D}:
We form a large sparse matrix \eqn{D \in R^{(n d) \times L}} using 
\code{Matrix::sparseMatrix}. Triplet indices (row, column, value) are 
collected efficiently.

\strong{Robust Initialization}:
Initialization uses the top \eqn{d} left singular vectors of \eqn{D}, typically 
computed via \code{irlba::irlba}. If \code{irlba} fails or returns a rank 
deficient result (less than \eqn{d} vectors), it falls back to initializing 
with random orthogonal matrices to ensure robustness.

\strong{Vectorized GPM Iteration}:
The core iteration avoids \eqn{O(n^2)} complexity by computing the update 
term \eqn{CO} using two efficient sparse matrix multiplications:
\enumerate{
  \item \eqn{Y <- D^T * stack(O_{old})}
  \item \eqn{CO_{stack} <- D * Y}
}
where \eqn{stack(O)} reshapes the \eqn{d \times d \times n} array of 
rotation matrices into an \eqn{(nd) \times d} matrix. The resulting 
\eqn{(nd) \times d} matrix \eqn{CO_{stack}} is then unstacked back into 
a \eqn{d \times d \times n} array.

\strong{Efficient Projection}:
Each \eqn{d \times d} slice of the unstacked update is projected onto the 
orthogonal group O(d). An efficient projection method (\code{.projO}) is used, 
switching between an eigenvalue-based method for small \eqn{d} and an 
SVD-based method for larger \eqn{d}.

\strong{Convergence Check}:
Convergence is assessed by comparing the Frobenius norm of the difference 
between consecutive projected iterates \eqn{O_{new}} and 
\eqn{O_{old}}. For relative tolerance, this difference is scaled by the 
Frobenius norm of the initial \eqn{O} matrices (calculated once).

\strong{Final Consensus A_est}:
After convergence, the consensus matrix \eqn{A_{est}} is computed. 
For each task \eqn{j}, we average the transformed data 
\eqn{O_i^T A_i(*, j_i)} only over subjects \eqn{i} in \eqn{S_j} that observed 
task \eqn{j}. Task counts (number of subjects observing each task \eqn{j}) are 
computed by directly iterating over \code{task_labels_list}, ensuring correctness 
even if input matrices contain explicit zeros.
}
\examples{
\donttest{
# Example with hyperdesign data
library(multidesign)

# Create example domains with partial task overlap
d1_data <- matrix(rnorm(50), 5, 10)  # 5 tasks x 10 features
d1_design <- data.frame(task = factor(c("A", "B", "C", "D", "E")))
d1 <- multidesign(d1_data, d1_design)

d2_data <- matrix(rnorm(40), 4, 10)  # 4 tasks x 10 features
d2_design <- data.frame(task = factor(c("A", "C", "D", "F")))
d2 <- multidesign(d2_data, d2_design)

# Create hyperdesign
hd <- hyperdesign(list(domain1 = d1, domain2 = d2))

# Perform alignment
result <- generalized_procrustes(hd, task)

# Check convergence and results
print(result$converged)
print(dim(result$A_est))  # Features x total tasks
}

\donttest{
# Simple example with 2 subjects and 3 tasks
A1 <- matrix(rnorm(12), 3, 4)  # Subject 1: 3 features x 4 tasks
A2 <- matrix(rnorm(9), 3, 3)   # Subject 2: 3 features x 3 tasks

# Task labels (partial overlap)
task_labels1 <- c(1, 2, 3, 4)  # Subject 1 observes tasks 1,2,3,4
task_labels2 <- c(1, 3, 5)     # Subject 2 observes tasks 1,3,5

# Run alignment
result <- generalized_procrustes(
  A_list = list(A1, A2),
  task_labels_list = list(task_labels1, task_labels2),
  L = 5,  # Total of 5 unique tasks
  max_iter = 50,
  verbose = FALSE
)

# Check results
print(result$converged)
print(dim(result$A_est))  # Should be 3x5
}

\donttest{
# Create example hyperdesign data
library(multidesign)

# Domain 1: 5 tasks x 10 features
d1_data <- matrix(rnorm(50), 5, 10)
d1_design <- data.frame(task = factor(c("A", "B", "C", "D", "E")))
d1 <- multidesign(d1_data, d1_design)

# Domain 2: 4 tasks x 10 features (partial overlap)
d2_data <- matrix(rnorm(40), 4, 10) 
d2_design <- data.frame(task = factor(c("A", "C", "D", "F")))
d2 <- multidesign(d2_data, d2_design)

# Create hyperdesign
hd <- hyperdesign(list(domain1 = d1, domain2 = d2))

# Perform alignment
result <- generalized_procrustes(hd, task)

# Access results
print(result$converged)
print(dim(result$A_est))  # 10 features x 6 total tasks
}
}
\references{
Gower, J. C. (1975). Generalized procrustes analysis. Psychometrika, 40(1), 
33-51.

Ten Berge, J. M. F. (1977). Orthogonal procrustes rotation for two or more 
matrices. Psychometrika, 42(2), 267-276.
}
\seealso{
\code{\link{generalized_procrustes.hyperdesign}}
}
