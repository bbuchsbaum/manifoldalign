% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_generic.R
\name{grasp}
\alias{grasp}
\title{Graph Alignment by Spectral Corresponding Functions (GRASP)}
\usage{
grasp(data, ...)
}
\arguments{
\item{data}{Input data object containing graph domains}

\item{...}{Additional arguments passed to specific methods. See 
\code{\link{grasp.hyperdesign}} for details on method-specific parameters 
such as \code{preproc}, \code{ncomp}, \code{q_descriptors}, \code{sigma}, 
\code{lambda}, \code{use_laplacian}, and \code{solver}}
}
\value{
A \code{multiblock_biprojector} object containing:
\itemize{
  \item \code{s}: Aligned spectral embeddings for all nodes
  \item \code{v}: Primal vectors for out-of-sample projection
  \item \code{assignment}: Node-to-node correspondence vector
  \item \code{rotation}: Orthogonal rotation matrix between spectral bases
  \item \code{mapping_matrix}: Diagonal functional correspondence matrix
  \item Additional metadata for reconstruction and validation
}
}
\description{
Performs GRASP alignment on graph data structures. GRASP tackles the "unrestricted" 
graph alignment problem where only graph structures are given, finding optimal 
node-to-node correspondences between graphs by matching functions defined on nodes.
}
\details{
The core idea of GRASP is to transfer functional maps from 3D shape analysis to 
graph alignment. Instead of directly matching nodes (which is hard), it matches 
functions defined on the nodes. By finding a robust mapping between basis functions 
on each graph, GRASP deduces the underlying node-to-node alignment as a by-product.


GRASP operates through five conceptual blocks:
\itemize{
  \item \strong{Block A}: Spectral basis construction using eigendecomposition 
    of graph Laplacians
  \item \strong{Block B}: Multi-scale node descriptors using heat kernel or 
    Personalized PageRank
  \item \strong{Block C}: Base alignment using Stiefel manifold optimization
  \item \strong{Block D}: Functional correspondence mapping
  \item \strong{Block E}: Final node-to-node assignment via linear assignment
}

The algorithm provides a global, multi-scale view of graph structure that is 
robust to noise and structural perturbations. For the pairwise case, complexity 
is dominated by the final assignment step (typically O(nÂ³)).

Key parameters:
\itemize{
  \item \code{ncomp}: Number of eigenvectors used (dimension of spectral basis)
  \item \code{q_descriptors}: Number of descriptor functions for multi-scale analysis
  \item \code{sigma}: Diffusion parameter controlling descriptor time scales
  \item \code{lambda}: Regularization balancing eigen-structure vs descriptor alignment
}
}
\examples{
\donttest{
# Example with hyperdesign graph data
library(multidesign)

# Create synthetic graph domains
set.seed(123)
domain1 <- list(
  x = matrix(rnorm(100), 50, 2),  # Node features
  design = data.frame(node_id = 1:50)
)
domain2 <- list(
  x = matrix(rnorm(100), 50, 2),
  design = data.frame(node_id = 1:50)  
)

# Create hyperdesign
hd <- hyperdesign(list(domain1 = domain1, domain2 = domain2))

# Run GRASP alignment with default parameters
result <- grasp(hd, ncomp = 20, q_descriptors = 50)

# Access alignment results
node_assignment <- result$assignment
aligned_embeddings <- result$s

# Use different parameters for robustness
result_robust <- grasp(hd, ncomp = 30, sigma = 1.0, lambda = 0.2)
}

}
\references{
Bogo, F., Romero, J., Loper, M., & Black, M. J. (2016). FAUST: Dataset and 
evaluation for 3D mesh registration. In Proceedings of the IEEE Conference 
on Computer Vision and Pattern Recognition (pp. 3794-3801).

Ovsjanikov, M., Ben-Chen, M., Solomon, J., Butscher, A., & Guibas, L. (2012). 
Functional maps: a flexible representation of maps between shapes. ACM 
Transactions on Graphics, 31(4), 1-11.
}
\seealso{
\code{\link{grasp.hyperdesign}}
}
