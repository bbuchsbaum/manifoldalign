% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_generic.R, R/parrot.R
\name{parrot}
\alias{parrot}
\title{Position-Aware Random Transport (PARROT) Network Alignment}
\usage{
parrot(data, anchors, ...)

parrot(data, anchors, ...)
}
\arguments{
\item{data}{Input data object containing network domains}

\item{anchors}{Name of anchor/correspondence variable for semi-supervised alignment}

\item{...}{Additional arguments passed to specific methods. See 
\code{\link{parrot.hyperdesign}} for details on method-specific parameters 
such as \code{preproc}, \code{ncomp}, \code{sigma}, \code{lambda}, 
\code{tau}, \code{solver}, \code{max_iter}, and \code{tol}}
}
\value{
A \code{multiblock_biprojector} object containing:
\itemize{
  \item \code{s}: Aligned network embeddings 
  \item \code{v}: Primal vectors for out-of-sample projection
  \item \code{alignment_matrix}: Soft alignment/transport plan between networks
  \item \code{transport_plan}: Dense transport matrix S
  \item \code{sdev}: Standard deviations of aligned components
  \item Additional metadata for reconstruction and validation
}

A \code{multiblock_biprojector} object containing:
\itemize{
  \item \code{s}: Aligned network embeddings 
  \item \code{v}: Primal vectors for out-of-sample projection
  \item \code{alignment_matrix}: Soft alignment/transport plan between networks
  \item \code{transport_plan}: Dense transport matrix S
  \item \code{sdev}: Standard deviations of aligned components
  \item Additional metadata for reconstruction and validation
}
}
\description{
Performs PARROT alignment on hyperdesign data structures. Aligns networks
using regularized optimal transport with position-aware features and consistency constraints.

Performs PARROT alignment on hyperdesign data structures. Aligns networks
using regularized optimal transport with position-aware features and consistency constraints.
}
\details{
PARROT tackles network alignment by formulating it as a regularized optimal transport
problem. The method incorporates position-aware features through Random Walk with Restart
(RWR) descriptors and enforces structural consistency through neighborhood-preserving
regularization terms.


PARROT operates through the following algorithmic components:
\itemize{
  \item \strong{Position-Aware Features}: Compute RWR descriptors capturing network position
  \item \strong{Cross-Network Cost}: Build transport cost matrix between networks
  \item \strong{Consistency Regularization}: Add structural similarity constraints
  \item \strong{Optimal Transport}: Solve regularized transport problem via Sinkhorn
}

The algorithm minimizes the objective:
\deqn{L(S) = \langle C, S \rangle + \lambda_1 \Omega_1(S) + \lambda_2 \Omega_2(S) + \tau H(S)}

where \eqn{C} is the position-aware cost matrix, \eqn{\Omega_1, \Omega_2} are consistency
regularizers, and \eqn{H(S)} is the entropy regularization term with parameter \eqn{\tau}.

Key parameters:
\itemize{
  \item \code{sigma}: RWR restart probability and diffusion parameter
  \item \code{lambda}: Consistency regularization weights
  \item \code{tau}: Entropy regularization parameter for Sinkhorn
  \item \code{solver}: Transport solver ("sinkhorn" or "exact")
}

PARROT tackles network alignment by formulating it as a regularized optimal transport
problem. The method incorporates position-aware features through Random Walk with Restart
(RWR) descriptors and enforces structural consistency through neighborhood-preserving
regularization terms.


PARROT operates through the following algorithmic components:
\itemize{
  \item \strong{Position-Aware Features}: Compute RWR descriptors capturing network position
  \item \strong{Cross-Network Cost}: Build transport cost matrix between networks
  \item \strong{Consistency Regularization}: Add structural similarity constraints
  \item \strong{Optimal Transport}: Solve regularized transport problem via Sinkhorn
}

The algorithm minimizes the objective:
\deqn{L(S) = \langle C, S \rangle + \lambda_1 \Omega_1(S) + \lambda_2 \Omega_2(S) + \tau H(S)}

where \eqn{C} is the position-aware cost matrix, \eqn{\Omega_1, \Omega_2} are consistency
regularizers, and \eqn{H(S)} is the entropy regularization term with parameter \eqn{\tau}.

Key parameters:
\itemize{
  \item \code{sigma}: RWR restart probability and diffusion parameter
  \item \code{lambda}: Consistency regularization weights
  \item \code{tau}: Entropy regularization parameter for Sinkhorn
  \item \code{solver}: Transport solver ("sinkhorn" or "exact")
}
}
\examples{
\donttest{
# Example with hyperdesign network data
library(multidesign)

# Create synthetic network domains
set.seed(123)
domain1 <- list(
  x = matrix(rnorm(200), 100, 2),  # Node features
  design = data.frame(
    node_id = 1:100,
    anchors = c(1:10, rep(NA, 90))  # First 10 nodes are anchors
  )
)
domain2 <- list(
  x = matrix(rnorm(200), 100, 2),
  design = data.frame(
    node_id = 1:100,
    anchors = c(1:10, rep(NA, 90))  # Corresponding anchors
  )
)

# Create hyperdesign
hd <- hyperdesign(list(domain1 = domain1, domain2 = domain2))

# Run PARROT alignment with default parameters
result <- parrot(hd, anchors = anchors)

# Access alignment results
transport_plan <- result$transport_plan
aligned_embeddings <- result$s

# Use different regularization settings
result_strong <- parrot(hd, anchors = anchors, lambda = 0.5, tau = 0.1)
}

\donttest{
# Example with hyperdesign network data
library(multidesign)
library(tibble)

# Create synthetic network domains (node features for PARROT)
set.seed(123)
X1 <- matrix(rnorm(200), 100, 2)  # Node features for domain 1
X2 <- matrix(rnorm(200), 100, 2)  # Node features for domain 2

# Create design data frames with anchor correspondences (PARROT uses anchors)
design1 <- tibble(
  node_id = 1:100,
  anchors = c(1:10, rep(NA, 90))  # First 10 nodes are anchors
)
design2 <- tibble(
  node_id = 1:100,
  anchors = c(1:10, rep(NA, 90))  # Corresponding anchors
)

# Create multidesign objects
md1 <- multidesign(X1, design1)
md2 <- multidesign(X2, design2)

# Create hyperdesign from multidesign objects
hd <- hyperdesign(list(domain1 = md1, domain2 = md2))

# Run PARROT alignment (uses anchors from design component)
result <- parrot(hd, anchors = anchors)

# Access alignment results
transport_plan <- result$transport_plan
aligned_embeddings <- result$s

# Use different regularization settings
result_strong <- parrot(hd, anchors = anchors, lambda = 0.5, tau = 0.1)
}

}
\references{
Wang, S., Chen, Z., Yu, X., Li, T., Yang, J., & Liu, X. (2022). PARROT: 
Position-aware regularized optimal transport for network alignment. 
In Proceedings of the 28th ACM SIGKDD Conference on Knowledge Discovery 
and Data Mining (pp. 1896-1905).

Wang, S., Chen, Z., Yu, X., Li, T., Yang, J., & Liu, X. (2022). PARROT: 
Position-aware regularized optimal transport for network alignment. 
In Proceedings of the 28th ACM SIGKDD Conference on Knowledge Discovery 
and Data Mining (pp. 1896-1905).
}
\seealso{
\code{\link{parrot.hyperdesign}}

\code{\link{parrot.hyperdesign}}
}
