# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

linear_sim_embed_cpp <- function(X, T, M, sigma_P, ncomp, alpha_p, maxit = 500L, tol = 1e-6) {
    .Call('_manifoldalign_linear_sim_embed_cpp', PACKAGE = 'manifoldalign', X, T, M, sigma_P, ncomp, alpha_p, maxit, tol)
}

#' Compute pairwise squared distances for connected nodes
#' 
#' @param X Feature matrix (n x d)
#' @param A Adjacency matrix (sparse, n x n)
#' @return Matrix of squared distances for edges
compute_edge_distances_cpp <- function(X, A) {
    .Call('_manifoldalign_compute_edge_distances_cpp', PACKAGE = 'manifoldalign', X, A)
}

#' Compute edge consistency gradient
#' 
#' Efficient computation of the gradient of edge consistency regularizer
#' 
#' @param S Current transport plan (n1 x n2)
#' @param A1 Adjacency matrix of network 1 (sparse)
#' @param A2 Adjacency matrix of network 2 (sparse)
#' @param X1 Features of network 1 (n1 x d)
#' @param X2 Features of network 2 (n2 x d)
#' @return Gradient matrix (n1 x n2)
compute_edge_gradient_cpp <- function(S, A1, A2, X1, X2) {
    .Call('_manifoldalign_compute_edge_gradient_cpp', PACKAGE = 'manifoldalign', S, A1, A2, X1, X2)
}

#' Compute neighborhood consistency gradient
#' 
#' Gradient of KL divergence term for neighborhood consistency
#' 
#' @param S_prev Previous transport plan
#' @param W1 Transition matrix of network 1
#' @param W2 Transition matrix of network 2
#' @param eps Small epsilon for numerical stability
#' @return Gradient matrix
compute_neighborhood_gradient_cpp <- function(S_prev, W1, W2, eps = 1e-16) {
    .Call('_manifoldalign_compute_neighborhood_gradient_cpp', PACKAGE = 'manifoldalign', S_prev, W1, W2, eps)
}

#' Compute anchor prior gradient
#' 
#' Gradient of KL divergence from anchor prior
#' 
#' @param S_prev Previous transport plan
#' @param anchor_idx1 Indices of anchors in network 1
#' @param anchor_idx2 Indices of anchors in network 2
#' @param anchor_vals1 Anchor values for network 1
#' @param anchor_vals2 Anchor values for network 2
#' @param eps Small epsilon for numerical stability
#' @return Gradient matrix
compute_anchor_gradient_cpp <- function(S_prev, anchor_idx1, anchor_idx2, anchor_vals1, anchor_vals2, eps = 1e-16) {
    .Call('_manifoldalign_compute_anchor_gradient_cpp', PACKAGE = 'manifoldalign', S_prev, anchor_idx1, anchor_idx2, anchor_vals1, anchor_vals2, eps)
}

#' Log-sum-exp trick for columns
#' 
#' Computes log(sum(exp(log_u + log_K[,j]))) for each column j
#' using the log-sum-exp trick for numerical stability
#' 
#' @param log_K Log-kernel matrix (n x m)
#' @param log_u Log potential vector (n x 1)
#' @return Log-sum-exp for each column (m x 1)
log_sum_exp_cols <- function(log_K, log_u) {
    .Call('_manifoldalign_log_sum_exp_cols', PACKAGE = 'manifoldalign', log_K, log_u)
}

#' Log-sum-exp trick for rows
#' 
#' Computes log(sum(exp(log_v + log_K[i,]))) for each row i
#' using the log-sum-exp trick for numerical stability
#' 
#' @param log_K Log-kernel matrix (n x m)
#' @param log_v Log potential vector (m x 1)
#' @return Log-sum-exp for each row (n x 1)
log_sum_exp_rows <- function(log_K, log_v) {
    .Call('_manifoldalign_log_sum_exp_rows', PACKAGE = 'manifoldalign', log_K, log_v)
}

#' Stabilized Sinkhorn algorithm in C++
#' 
#' Implements the log-domain stabilized Sinkhorn algorithm for optimal transport
#' 
#' @param C Cost matrix (n x m)
#' @param tau Entropy regularization parameter
#' @param max_iter Maximum number of iterations
#' @param tol Convergence tolerance
#' @return Transport plan matrix S
solve_sinkhorn_stabilized_cpp <- function(C_in, tau, max_iter, tol) {
    .Call('_manifoldalign_solve_sinkhorn_stabilized_cpp', PACKAGE = 'manifoldalign', C_in, tau, max_iter, tol)
}

#' Fast doubly stochastic matrix normalization
#' 
#' Normalizes a matrix to be doubly stochastic (rows and columns sum to specified values)
#' 
#' @param S Matrix to normalize
#' @param mu Target row sums
#' @param nu Target column sums
#' @param tol Convergence tolerance
#' @param max_iter Maximum iterations
#' @return Normalized matrix
normalize_doubly_stochastic_cpp <- function(S, mu, nu, tol = 1e-9, max_iter = 20L) {
    .Call('_manifoldalign_normalize_doubly_stochastic_cpp', PACKAGE = 'manifoldalign', S, mu, nu, tol, max_iter)
}

#' Compute squared Euclidean distance matrix
#' 
#' Efficient computation of pairwise squared distances
#' 
#' @param X1 First matrix (n1 x d)
#' @param X2 Second matrix (n2 x d)
#' @return Distance matrix (n1 x n2)
compute_squared_distances_cpp <- function(X1, X2) {
    .Call('_manifoldalign_compute_squared_distances_cpp', PACKAGE = 'manifoldalign', X1, X2)
}

#' Solve Sylvester equation for RWR cost
#' 
#' Iterative solution of: C_rwr = (1+β)C_node + (1-β)γ * W1 * C_rwr * W2^T
#' 
#' @param W1 Transition matrix of network 1
#' @param W2T Transpose of transition matrix of network 2
#' @param C_node Node-level cost matrix
#' @param beta RWR restart probability
#' @param gamma Cross-graph discount factor
#' @param tol Convergence tolerance
#' @param max_iter Maximum iterations
#' @return Solution matrix C_rwr
solve_sylvester_rwr_cpp <- function(W1, W2T, C_node, beta = 0.15, gamma = 0.1, tol = 1e-6, max_iter = 50L) {
    .Call('_manifoldalign_solve_sylvester_rwr_cpp', PACKAGE = 'manifoldalign', W1, W2T, C_node, beta, gamma, tol, max_iter)
}

#' Vectorized RWR computation
#' 
#' Compute Random Walk with Restart for multiple restart vectors simultaneously
#' 
#' @param W_transpose Transpose of transition matrix
#' @param E Matrix of restart vectors (columns are different restart distributions)
#' @param sigma Restart probability
#' @param max_iter Maximum iterations
#' @param tol Convergence tolerance
#' @return RWR result matrix
compute_rwr_vectorized_cpp <- function(W_transpose, E, sigma, max_iter, tol) {
    .Call('_manifoldalign_compute_rwr_vectorized_cpp', PACKAGE = 'manifoldalign', W_transpose, E, sigma, max_iter, tol)
}

#' Compute PARROT cost matrix
#' 
#' Complete cost matrix computation including Sylvester equation
#' 
#' @param X1 Features of network 1
#' @param X2 Features of network 2
#' @param R1 RWR descriptors of network 1
#' @param R2 RWR descriptors of network 2
#' @param W1 Transition matrix of network 1
#' @param W2 Transition matrix of network 2
#' @param alpha Weight for attribute vs RWR cost
#' @param sigma RWR restart probability
#' @param gamma Cross-graph discount factor
#' @return Position-aware cost matrix
compute_parrot_cost_cpp <- function(X1, X2, R1, R2, W1, W2, alpha = 0.5, sigma = 0.15, gamma = 0.1) {
    .Call('_manifoldalign_compute_parrot_cost_cpp', PACKAGE = 'manifoldalign', X1, X2, R1, R2, W1, W2, alpha, sigma, gamma)
}

